<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Harsh's blog (sympy)</title><link>https://hargup.github.io/</link><description></description><language>en</language><lastBuildDate>Wed, 30 Jul 2014 00:38:53 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>week 10: Radical equations</title><link>https://hargup.github.io/posts/week-10.html</link><dc:creator>Harsh Gupta</dc:creator><description>&lt;p&gt;This week I worked on the solvers for the equations with radicals.
Suppose you have to solve&lt;/p&gt;
&lt;p&gt;$$ \sqrt{x} + x - 2 = 0 $$.&lt;/p&gt;
&lt;p&gt;then you have to move the radical to the right hand side of the equation.&lt;/p&gt;
&lt;p&gt;$$ x - 2 = - \sqrt{x} $$&lt;/p&gt;
&lt;p&gt;and then square at both sides&lt;/p&gt;
&lt;p&gt;$$ x^2 - 4x + 4 = x $$&lt;/p&gt;
&lt;p&gt;Now the equation is a polynomial in \( x \) can be solved with usual
polynomial solving methods. Note that squaring both sides produce some extra
solutions and we will have to check all the solutions obtained against the
original equation.  If there are more than one radicals involved we may
have to apply the method recursively. For example in solving
\( \sqrt{2x + 9} - \sqrt{x + 1} - \sqrt{x + 4} = 0 \)
the method will recurse twice.&lt;/p&gt;
&lt;p&gt;To implement the method I tried a pattern matching approach.
The
squaring part is easy the tricky part is identifying which part to move to
the right hand side. First I tried to match the expression with the form
&lt;code&gt;sqrt(p) + q&lt;/code&gt; but it failed even for case like &lt;code&gt;4*sqrt(x) + x - 2&lt;/code&gt; because no
pattern matched to it. I had to use &lt;code&gt;a*sqrt(p) + q&lt;/code&gt; with the condition that the
expression matched to a shouldn't be zero. Now I can simply move the expression
matched with &lt;code&gt;p&lt;/code&gt; and terms multiplicated with it to the RHS and square both
the sides.&lt;/p&gt;
&lt;p&gt;Notice that this method for solving sqrt equation can work with any radical
equation, if it were cube root instead of sqrt I just had to cube both the
sides. OK so how do I mathch that expression? I tried to pattern matching with
assumptions on the wild symbols but it doesn't work.  I tried to match with
somthing like &lt;code&gt;a*p**Rational(1, m) + q&lt;/code&gt; but this also didn't work out because
Rational(1, m) raises TypeError no matter what the assumption on the variable
are.  There is a proposal for a new pattern matcher, I have not closely checked
the details but it will be able to work with assumption. You can see the
proposal on the wiki
&lt;a href="https://github.com/sympy/sympy/wiki/Proposal-for-a-new-pattern-matching"&gt;here&lt;/a&gt;
and if it is implemented then things will be good but I can't wait for it.
I had no other option to check term by term for rational power. Here's the
implementation&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;_has_rational_power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Wild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Wild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'p'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Wild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'q'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;pattern_match&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;pattern_match&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;pattern_match&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Zero&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern_match&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;pattern_match&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;One&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pattern_match&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern_match&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;Pow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern_match&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;Mul&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nl"&gt;else:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;_has_rational_power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern_match&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;</description><category>sympy</category><guid>https://hargup.github.io/posts/week-10.html</guid><pubDate>Tue, 29 Jul 2014 12:09:01 GMT</pubDate></item><item><title>week 9</title><link>https://hargup.github.io/posts/week-9.html</link><dc:creator>Harsh Gupta</dc:creator><description>&lt;p&gt;This week I moved back to college and my classes have restarted. This week
I worked on a PR to allow infinitely indexed &lt;code&gt;Range&lt;/code&gt;. See
https://github.com/sympy/sympy/pull/7741. While doing this PR I discovered
that you cannot monkey patch &lt;code&gt;object&lt;/code&gt; to assign some attribute. And I want to
mention that Sergey(one of my mentors) is damn good reviewer.&lt;/p&gt;</description><category>sympy</category><guid>https://hargup.github.io/posts/week-9.html</guid><pubDate>Sat, 19 Jul 2014 18:50:01 GMT</pubDate></item><item><title>week 7</title><link>https://hargup.github.io/posts/week-7.html</link><dc:creator>Harsh Gupta</dc:creator><description>&lt;h2&gt;Week 7, 8&lt;/h2&gt;
&lt;h3&gt;Fu Simplification&lt;/h3&gt;
&lt;p&gt;In the early part of the week 7 was thinking and working on design decisions.
I want the code to be very modular so that it could be easily extended by
people other than me. This came up in a meeting with Matthew and I want the
solvers to be like the Fu simplification explained by Matthew in this &lt;a href="https://www.youtube.com/watch?v=QldxygVVj-s&amp;amp;list=PLYx7XA2nY5GfuhCvStxgbynFNrxr3VFog&amp;amp;index=20"&gt;Scipy
Talk&lt;/a&gt;.
The idea was that we can see solving an equation as series of transformations.
If we have a lot of small transformations such that the input type is same as
output type, and some notion of what makes a "better" output we can search though
the list of transformations running one on top of other. I also posted about
it on the &lt;a href="https://groups.google.com/forum/#!topic/sympy/42GdMJ9ssyM"&gt;mailing
list&lt;/a&gt; which brought
out some flaws in the preliminary design. The idea is pretty crude in the
current stage and I'll have to look deeper into it, but not now.&lt;/p&gt;
&lt;p&gt;I also discussed about the implementing a pattern dispached based solver
suggested by &lt;a href="https://groups.google.com/d/msg/sympy/moSEFHop0n4/e2hBKRQ9WP4J"&gt;F.B&lt;/a&gt;
on the mailing list. But we decided that it will be better if we finish the
equation solver by the current technique first.&lt;/p&gt;
&lt;h3&gt;Intersection with S.Reals&lt;/h3&gt;
&lt;p&gt;I decribed in the last post that one way to solve trigonometric equation is
rewriting them in terms of \( exp \). But that is \( exp \) in the complex domain and
the solution of \(exp(x) = a \) is \( \left\{i \left(2 \pi
n + \arg{\left (a \right )}\right) + \log{\left
(\left\lvert{a}\right\rvert \right )}\; |\; n \in \mathbb{Z}\right\}
\). Hence we have to filter out real solutions from the obtained solutions.
The filering is equivalent to the intersection of the solutions with the \( \mathbb{R}
\) set. Suppose \( g(x) \) and \( h(x) \) are real valued functions and we
have to perform
$$ \mathbb{R} \cap \left\{g{\left (n \right )} + i h{\left (n \right )}\; |\; n \in \mathbb{Z}\right\} $$
then the answer will be simply
$$ \left\{g{\left (n \right )}\; |\; n \in \left\{h{\left (n \right )} = 0\; |\; n \in \mathbb{Z}\right\}\right\} $$&lt;/p&gt;
&lt;p&gt;Separate the real and imaginary parts and equate the imaginary to zero
but the problem was with the assumptions on the symbols. For example while
separating real and imaginary parts of the equation.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;In&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;as_imag_real&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That is because &lt;code&gt;n&lt;/code&gt; is by default complex, even in the &lt;code&gt;Lambda(..).expr&lt;/code&gt;.
I wrote some code to decide the
assumption on the variable of imageset from the baseset. See &lt;a href="https://github.com/sympy/sympy/pull/7694"&gt;PR
7694&lt;/a&gt;.
There was another issue that needs to be resolved
&lt;code&gt;S.Integers.intersect(S.Reals)&lt;/code&gt; doesn't evaluate to &lt;code&gt;S.Reals&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;LambertW and Multivariate Solvers&lt;/h3&gt;
&lt;p&gt;The method to solve equation containing exp and log function is using the
LambertW function. LambertW function is the inverse of \( x \exp(x) \).  The
function is multivariate function both for the real and complex
domains and Sympy has only one branch implemented. This also leads us to loss
of solutions. Aaron gave an example
&lt;a href="https://github.com/sympy/sympy/pull/2723#issuecomment-33760912"&gt;here&lt;/a&gt;. But I'm
pretty unfamiliar with solving by LambertW and LambertW itself and it will take
me some time to build an understanding of them.
As an ad hoc solution I'm using the code in the &lt;code&gt;_tsolve&lt;/code&gt; in the
&lt;code&gt;solvers.solvers&lt;/code&gt; module to do at least what the current solvers can do.&lt;/p&gt;
&lt;p&gt;When the importing of &lt;code&gt;_tsolve&lt;/code&gt; method was done. I started working on the
multivariate solvers. Here's how the current multivariate solvers work:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solving single multivariate equation&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;count the number of free symbols in f - no of symbols for
equation. If the equation has exactly one symbol which is not asked for then
use &lt;code&gt;solve_undetermined_coeffs&lt;/code&gt;, the &lt;code&gt;solve_undetermined_coeffs&lt;/code&gt; find the
values of the coefficient in a univariate polynomial such that it always
equates to zero.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Then for each symbol &lt;code&gt;solve_linear&lt;/code&gt; is tried which tries to find a solution
of that symbol in terms of constants or other symbols, the docstring says&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;No&lt;/span&gt; &lt;span class="n"&gt;simplification&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;than&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;True&lt;/span&gt; &lt;span class="n"&gt;expansion&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;so&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;solution&lt;/span&gt; &lt;span class="n"&gt;will&lt;/span&gt; &lt;span class="n"&gt;correspond&lt;/span&gt; &lt;span class="n"&gt;strictly&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;unique&lt;/span&gt; &lt;span class="n"&gt;solution&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So we don't have to worry about loosing a solution. For every symbol it is
checked if doesn't depend on previously solved symbols, if it does that
solution is discarded.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For the symbols for which the above method failed, the &lt;code&gt;_solve&lt;/code&gt; function is
called for the equation for that variable and as above if the solution contains
a variable already solved then that solution is discarded.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;System of equations in multiple variables&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Try to convert the system of equations into a system of polynomial equation
  in variables&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If all the equations are linear solve then using &lt;code&gt;solve_linear_system&lt;/code&gt;, check
  the result and return it. If asked for particular solution solve using
  &lt;code&gt;minsolve_linear_system&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the number of symbols is same as the size of the system solve the
  polynomial system using &lt;code&gt;solve_poly_system&lt;/code&gt;. In case the system is
  over-determined All the free symbols intersection the variables asked for are
  calculated. Then for every subset of such symbols of length equal to that of
  the system, an attempt to solve the equations by &lt;code&gt;solve_poly_system&lt;/code&gt; is made.
  Here if any of the solution depends on previously solved system the solution
  is discarded.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the case there are failed equations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For every know result:&lt;/li&gt;
&lt;li&gt;Substitute every thing into the failed equation and see if the equation turns to zero.
  if it does accept the result otherwise put it in the bad_results group.&lt;/li&gt;
&lt;li&gt;Then try to solve try to solve the failed equation using &lt;code&gt;solve&lt;/code&gt; for each symbol.&lt;/li&gt;
&lt;li&gt;If that solution depends on any other previously solved symbols
  discard it.&lt;/li&gt;
&lt;li&gt;If it doesn't satisfy other equations, discard it.&lt;/li&gt;
&lt;li&gt;Check if the solution doesn't set any denominator to zero, if it does
  discard that solution.&lt;/li&gt;
&lt;li&gt;If it satisfies the above conditions substitute this value in know
  solutions and add it as a new result.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><category>mathjax</category><category>sympy</category><guid>https://hargup.github.io/posts/week-7.html</guid><pubDate>Sat, 12 Jul 2014 14:00:01 GMT</pubDate></item><item><title>week 6</title><link>https://hargup.github.io/posts/week-6.html</link><dc:creator>Harsh Gupta</dc:creator><description>&lt;h3&gt;Solving Trigonometric Function (part II)&lt;/h3&gt;
&lt;p&gt;There is another technique to solve trigonometric function. Just as every
trigonometric function can be written in term of \( \tan \) it can also be written
in terms of \( \exp \).&lt;/p&gt;
&lt;p&gt;$$ sin(x) = - \frac{i}{2} \left(e^{i x} - e^{- i x}\right) $$
$$ cos(x) = \frac{e^{i x}}{2} + \frac{1}{2} e^{- i x} $$
$$ tan(x) = \frac{i \left(- e^{i x} + e^{- i x}\right)}{e^{i x} + e^{- i x}} $$
$$ cot(x) = \frac{i \left(e^{i x} + e^{- i x}\right)}{e^{i x} - e^{- i x}} $$&lt;/p&gt;
&lt;p&gt;So, solving a trigonometric equation is equivalent to solving a rational
function in \( \exp \). Note: here the \( \exp \) is in complex domain and
equation \( exp(x) = y \) has solution
\( \left\{i \left(2 \pi n + \arg{\left (y \right )}\right) + \log{\left (\left\lvert{y}\right\rvert \right )}\; |\; n \in \mathbb{Z}\right\} \)
when solved for \( x \).&lt;/p&gt;</description><category>mathjax</category><category>sympy</category><guid>https://hargup.github.io/posts/week-6.html</guid><pubDate>Wed, 02 Jul 2014 08:43:01 GMT</pubDate></item><item><title>week 5</title><link>https://hargup.github.io/posts/week-5.html</link><dc:creator>Harsh Gupta</dc:creator><description>&lt;h3&gt;Solving Trigonometric Function (part I)&lt;/h3&gt;
&lt;p&gt;This week I spend time on making trigonometric solvers work.
Every trigonometric function can be written in terms of tan.&lt;/p&gt;
&lt;p&gt;$$ sin(x) = \frac{2*tan(x/2)}{tan^{2}(x/2)} $$&lt;/p&gt;
&lt;p&gt;$$ cos(x) = \frac{-tan^{2}(x/2) + 1}{tan^{2}(x/2) + 1} $$&lt;/p&gt;
&lt;p&gt;$$ cot(x) = \frac{1}{tan(x)} $$&lt;/p&gt;
&lt;p&gt;A basic technique to solve trigonometric equations can be rewriting the equation in terms of tan.
And if the equation is made by addition, multiplication or quotient of
trigonometric functions then the transformed equation is a equivalent to a rational
function in tan. That equation can be solved by the usual polynomial
solving techniques.&lt;/p&gt;
&lt;p&gt;Taking the example from the &lt;a href="https://github.com/sympy/sympy/wiki/solvers"&gt;doc&lt;/a&gt;
\( cos(x) + sin(x) \) gets converted to
\( \frac{-tan^{2}(x/2) + 2*tan(x/2) + 1}{tan^{2}(x/2) + 1} \)&lt;/p&gt;
&lt;p&gt;The solution of this equations is \( tan(x/2) = 1 +- sqrt(2) \).
Since the inverse of tan is
\( \left\{2 \pi n + \operatorname{atan}{\left (y \right )}\; |\; n \in \mathbb{Z}\right\} \)
the solution of the given equation is
$$ \left\{2 \pi n - \frac{\pi}{8}\; |\; n \in \mathbb{Z}\right\} \cup \left\{2 \pi n + \frac{3 \pi}{8}\; |\; n \in \mathbb{Z}\right\} $$&lt;/p&gt;
&lt;p&gt;Though it appears this technique should work universally for trigonometric
equation it fails for even \( sin(x) = 0 \). From the table above
\( sin(x) = \frac{2*tan(x/2)}{tan^{2}(x/2)} \)
So, the \( sin(x) = 0 \) occurs at \( tan(x/2) = 0 \) which has solution
\( \left\{2 \pi n\; |\; n \in \mathbb{Z}\right\} \)
But the solution is \( \left\{ \pi n\; |\; n \in \mathbb{Z}\right\} \)
. Why are we missing some solutions? The
reason is \( sin(x) = 0 \) also occurs when denominator tends to \( \infty \),
i.e.,
the values where \( tan^{2}(x/2) + 1 \) tends to \( \infty \).
We had encountered a similar problem for the solution of
$$ \frac{1}{\left(\frac{x}{x + 1} + 3\right)^{2}} $$&lt;/p&gt;
&lt;p&gt;here \( x = -1 \) is not a point in the domain of the of the equation. The solver
simplifies the equation to&lt;/p&gt;
&lt;p&gt;$$ \frac{\left(x + 1\right)^{2}}{\left(4 x + 3\right)^{2}} $$&lt;/p&gt;
&lt;p&gt;which extends the domain to include the point \( x = -1 \) which is also the
solution to the transformed equation. There we wrote a sub procedure
&lt;code&gt;domain_check&lt;/code&gt; to verify if the returned solution is part of the domain of the
original equation. The problem here is slightly different in the sense that
transforming the equation decreases the domain of the solutions and not increase
it.&lt;/p&gt;
&lt;p&gt;To find such solution we have allow \( \infty \) to be solution to equations, we
will be working on extended reals instead of just reals.  I think this change
will simplify a lot of things.&lt;/p&gt;
&lt;p&gt;Another thing which should be taken care off is that we cannot naively search
for the values for which the denominator tends to infinity as for the same
value numerator might also attain infinitely large value, we will have to
conceder the limiting value of the equation.&lt;/p&gt;
&lt;!--
A technique followed by current solvers is.
- Git Rebase
- The tan technique
- The problems with tan technique
- the Exp technique
- The problem with exp technique
- Complex logarithms and multivalued(set valued) functions
--&gt;</description><category>mathjax</category><category>sympy</category><guid>https://hargup.github.io/posts/week-5.html</guid><pubDate>Thu, 26 Jun 2014 11:43:01 GMT</pubDate></item><item><title>week 4</title><link>https://hargup.github.io/posts/week-4.html</link><dc:creator>Harsh Gupta</dc:creator><description>&lt;h3&gt;Intersections of Infinitely indexed sets&lt;/h3&gt;
&lt;p&gt;This week I implemented a method to do intersection of imagesets using the
solutions of Diophantine equations at &lt;a href="https://github.com/sympy/sympy/pull/7587"&gt;PR&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Say you have
to find the intersection of sets &lt;code&gt;2*n| n in Integers&lt;/code&gt; and &lt;code&gt;3*m| m in Integers&lt;/code&gt;.
The intersection of these sets is the set of the common values in the two sets,
which in this case is equivalent to the values of &lt;code&gt;n&lt;/code&gt; for which the equation &lt;code&gt;2*n - 3*m&lt;/code&gt; has
some integral solution in &lt;code&gt;m&lt;/code&gt;. Or the values of &lt;code&gt;m&lt;/code&gt; for which the &lt;code&gt;2*n - 3*m&lt;/code&gt;
has some integral solution in &lt;code&gt;n&lt;/code&gt;. Diophantine equations are equations for
which only integral solutions are searched for.
The Diophantine module was written by
&lt;a href="https://github.com/thilinarmtb"&gt;Thilina&lt;/a&gt; as his GSoC project last year.
It gives the parametric solution for such equation.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;diophantine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The Solution is sorted according to alphabetic order of the variables involved.
So the value of LHS (&lt;code&gt;2*n&lt;/code&gt;) for which the equation is &lt;code&gt;2*(-3*t)&lt;/code&gt; that is &lt;code&gt;-6*t&lt;/code&gt;
and it is the intersection of the sets described above &lt;code&gt;-6*t| t in Integers&lt;/code&gt;.
Since &lt;code&gt;-6*t| t in Integers&lt;/code&gt; is same as &lt;code&gt;6*t| t in Integers&lt;/code&gt; I also wrote some
simplification rules for the imagesets with Integers as baseset.&lt;/p&gt;
&lt;h3&gt;Sets for Invert Function&lt;/h3&gt;
&lt;p&gt;The sets module turned out to be better than I expected. I had a perception
that substitutions doesn't work properly with sets and I have even opened an
&lt;a href="https://github.com/sympy/sympy/issues/7483"&gt;issue&lt;/a&gt; for that but it turned out
I hadn't looked closely enough. It worked well for the free variables and it
didn't worked for the things it shouldn't work i.e., the bound variables in the
imagesets.&lt;/p&gt;
&lt;p&gt;Using sets simplified the code. All the list comprehensions like this
&lt;code&gt;[i.subs(symbol, symbol/g) for i in _invert(h, symbol)]&lt;/code&gt; were converted to
simple substitutions for sets and other sets operations.  &lt;code&gt;_invert(h,
symbol).subs(symbol, symbol/g)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Just by changing the output of invert to sets, then by adding the inverse of
trigonometric function and writing the code to rewrite then as tan I was able
to return all the solutions of the equations like &lt;code&gt;cos(x) + sin(x) == 0&lt;/code&gt; it
turned to out to easier than I thought. Using sets as output makes thinking
about the mathematics of the solvers much more easier and the code comes
out to be pretty natural. Now when we can see the results I can surely say
there can be no better output for solvers than sets.&lt;/p&gt;
&lt;p&gt;This week I'll study LambertW function and then code additional techniques to
solve real equations. I'll also try to figure out techniques to perform Union
on infinitely indexed sets.&lt;/p&gt;</description><category>GSoC</category><category>sympy</category><guid>https://hargup.github.io/posts/week-4.html</guid><pubDate>Wed, 18 Jun 2014 05:59:01 GMT</pubDate></item><item><title>week 3</title><link>https://hargup.github.io/posts/week-3.html</link><dc:creator>Harsh Gupta</dc:creator><description>&lt;p&gt;Hi,
At the start of this week I wrote a method to check if a given solution
lies in the domain of the equation or not. The problem it targeted was equations like &lt;code&gt;(x
- 1)/(1 + 1/(x - 1))&lt;/code&gt; though at &lt;code&gt;x = 1&lt;/code&gt; the eqution has value zero the point is
not present in the domain of the given equation. Though there is some
disagreement on the implementation, the idea was to traverse the expression
tree and check if any of the subexpression goes unbounded for the given
value.  Later I observed that caching was messing with the tests. Sometimes
the tests passed and sometimes the same test suit run without any
modification in the code failed. To do the check on the subexpressions I need
to have a copy of the original equation before the solver performs any
simplification on it. Being not sure of the mutability of the equations
I used deepcopy to copy the original equation to a variable. Later in a
meeting we figured out that deepcopy was messing with caching. Aaron told me
that every expression in sympy is immutable so don't need to perform deepcopy
on anything.&lt;/p&gt;
&lt;p&gt;This week we will restart working on the sets to represent infinite solutions,
Almost every equation in complex domain other than polynomials and rationals
has infinitly many solutions. For example even the simple equation &lt;code&gt;exp(x) ==
1&lt;/code&gt; has infinitely many solutions that is &lt;code&gt;i*2*n*pi&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is an integer.
To return these solutions we first need to have infrastructure to handle them.
The old(current) solvers does it wrong, it implicity mixes up the complex and real
domains, the answer it returns to &lt;code&gt;exp(x) == 1&lt;/code&gt; is only &lt;code&gt;[0]&lt;/code&gt;. Earlier I was also doing it wrong
so I decided that I should have two seperate solvers for reals and complex
instead of one. This also simplifed the code for the reals solvers to a large
extent.&lt;/p&gt;</description><category>GSoC</category><category>sympy</category><guid>https://hargup.github.io/posts/week-3.html</guid><pubDate>Mon, 09 Jun 2014 14:50:06 GMT</pubDate></item><item><title>Week 1 and Week 2</title><link>https://hargup.github.io/posts/week-1-and-week-2.html</link><dc:creator>Harsh Gupta</dc:creator><description>&lt;p&gt;Hi, As I told you about in the previous post, My work for this summer will be
improving the current equation solvers of sympy. There are basically three
thing I'll have to do.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a basic set infrastructure for solvers to return sets.&lt;/li&gt;
&lt;li&gt;Rewrite the current solvers to be clean and robust.&lt;/li&gt;
&lt;li&gt;On the top of 1 and 2 write new solvers and function, they will returning
   and handling all the solutions of equations like &lt;code&gt;sin(x) == 0&lt;/code&gt; and a general
   singularity finder.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can look at the details in my
&lt;a href="https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers"&gt;proposal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A started working on the sets module in the community bonding period, basically
writing a set difference class at &lt;a href="https://github.com/sympy/sympy/pull/7462"&gt;this
PR&lt;/a&gt; , I try to get it merged by the
end of this week.&lt;/p&gt;
&lt;p&gt;Set are a pretty general mathematical constructs, and you can solve a lot of
hard problems if you could compute general set operations. The whole number
theory can be defined in terms of sets. So, computing general set operations,
e.g, intersection, unions is pretty hard problem too and we should not aim to
do all them.  In a meeting with Matthew and Sergey we discussed that it would
    be better if complete the part 2 first. It will give a general idea about
    what capabilities of sets we need.  Also some sets problems can be reduced
    to equations and vice versa.  &lt;!-- Explain --&gt;&lt;/p&gt;
&lt;p&gt;I've started working on the univariate solvers &lt;a href="https://github.com/sympy/sympy/pull/7523"&gt;at
PR&lt;/a&gt;.  My aim for this
week will be.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Completing the rational solvers&lt;/li&gt;
&lt;li&gt;Getting the open PR for the sets merged.&lt;/li&gt;
&lt;/ol&gt;</description><category>GSoC</category><category>sympy</category><guid>https://hargup.github.io/posts/week-1-and-week-2.html</guid><pubDate>Mon, 02 Jun 2014 11:45:54 GMT</pubDate></item></channel></rss>